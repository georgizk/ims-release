package endpoints

import (
	"../config"
	"../models"
	"../storage_provider"

	"archive/zip"
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

// RegisterReleaseHandlers attaches the closures generated by each function defined below
// to handle incoming requests to the appropriate endpoint using a subrouter with an
// appropriate prefix, specified in main.
func RegisterReleaseHandlers(r *mux.Router, db *sql.DB, cfg *config.Config, sp storage_provider.Binary) {
	root := "/projects/{projectId:[0-9]+}/releases"
	sr := r.PathPrefix(root).Subrouter()
	r.HandleFunc(root, listReleases(db, cfg)).Methods("GET")
	r.HandleFunc(root, createRelease(db, cfg)).Methods("POST")
	sr.HandleFunc("/{releaseId:[0-9]+}", getRelease(db, cfg)).Methods("GET")
	sr.HandleFunc("/{releaseId:[0-9]+}", updateRelease(db, cfg)).Methods("PUT")
	sr.HandleFunc("/{releaseId:[0-9]+}", deleteRelease(db, cfg)).Methods("DELETE")
	sr.HandleFunc("/{releaseId:[0-9]+}/download/{name:.*}", downloadRelease(db, cfg, sp)).Methods("GET")
}

// GET /projects/{projectId}/releases

type listReleasesRequest struct {
	ProjectID uint32
}

type listReleasesResponse struct {
	Error    *string          `json:"error"`
	Releases []models.Release `json:"releases"`
}

// listReleases produces a list of all releases under a given project.
// It accepts an "ordering" parameter, which can be either "newest" or "oldest"
// to specify which should come first.
func listReleases(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		vars := mux.Vars(r)
		request := listReleasesRequest{0}
		_, parseErr := fmt.Sscanf(vars["projectId"], "%d", &request.ProjectID)

		encoder := json.NewEncoder(w)
		if parseErr != nil {
			log.Println("[---] Parse error:", parseErr)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId must be an integer ID."
			encoder.Encode(listReleasesResponse{&errMsg, []models.Release{}})
			return
		}
		releases, listErr := models.ListReleases(db, request.ProjectID)
		if listErr != nil {
			log.Println("[---] List error:", listErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not list releases. Please check that the projectId is correct or try again later."
			encoder.Encode(listReleasesResponse{&errMsg, []models.Release{}})
			return
		}
		encoder.Encode(listReleasesResponse{nil, releases})
	}
}

// POST /projects/{projectId}/releases

type createReleaseRequest struct {
	ProjectID  uint32 // Pulled from the URL parameters
	Identifier string `json:"identifier"`
	Version    uint32 `json:"version"`
	Status     string `json:"status"`
}

type createReleaseResponse struct {
	Error   *string `json:"error"`
	Success bool    `json:"success"`
	Id      uint32  `json:"id"`
}

// createRelease inserts a new release into the database.
func createRelease(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := createReleaseRequest{}
		vars := mux.Vars(r)
		_, parseErr := fmt.Sscanf(vars["projectId"], "%d", &request.ProjectID)
		decoder := json.NewDecoder(r.Body)
		defer r.Body.Close()
		decodeErr := decoder.Decode(&request)

		encoder := json.NewEncoder(w)
		if parseErr != nil {
			log.Println("[---] Parse error:", parseErr)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId must be an integer project ID."
			encoder.Encode(createReleaseResponse{&errMsg, false, 0})
			return
		}

		project, findErr := models.FindProject(db, request.ProjectID)
		if findErr != nil {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		if decodeErr != nil {
			log.Println("[---] Decode error:", decodeErr)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "JSON format error or missing field detected."
			encoder.Encode(createReleaseResponse{&errMsg, false, 0})
			return
		}
		release := models.NewRelease(project.Id, request.Version, request.Identifier)
		release.Status = request.Status
		insertErr := release.Save(db)
		if insertErr != nil {
			log.Println("[---] Insert error:", insertErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not create new release. Please check that the status is valid or try again later."
			encoder.Encode(createReleaseResponse{&errMsg, false, 0})
			return
		}
		encoder.Encode(createReleaseResponse{nil, true, release.Id})
	}
}

// GET /projects/{projectId}/releases/{releaseId}

type getReleaseRequest struct {
	ProjectID uint32
	ReleaseID uint32
}

type getReleaseResponse struct {
	Error      *string   `json:"error"`
	Identifier string    `json:"identifier"`
	Scanlator  string    `json:"scanlator"`
	Version    uint32    `json:"version"`
	Status     string    `json:"status"`
	ReleasedOn time.Time `json:"releasedOn"`
}

// getRelease obtains information about a specific release.
func getRelease(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := getReleaseRequest{}
		vars := mux.Vars(r)
		_, parseErr1 := fmt.Sscanf(vars["projectId"], "%d", &request.ProjectID)
		_, parseErr2 := fmt.Sscanf(vars["releaseId"], "%d", &request.ReleaseID)

		encoder := json.NewEncoder(w)
		if parseErr1 != nil || parseErr2 != nil {
			log.Printf("[---] Parse error: %v || %v\n", parseErr1, parseErr2)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId and releaseId must be integer IDs."
			encoder.Encode(getReleaseResponse{&errMsg, "", "", 0, models.RStatusUnknownStr, time.Now()})
			return
		}
		project, findErr := models.FindProject(db, request.ProjectID)
		if findErr != nil {
			log.Printf("[---] Find error:", findErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not find requested project. Please check that the projectId is correct or try again later."
			encoder.Encode(getReleaseResponse{&errMsg, "", "", 0, models.RStatusUnknownStr, time.Now()})
			return
		}
		release, findErr := models.FindRelease(db, project.Id, request.ReleaseID)
		if findErr != nil {
			log.Printf("[---] Find error:", findErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not find requested release. Please check that the releaseId is correct or try again later."
			encoder.Encode(getReleaseResponse{&errMsg, "", "", 0, models.RStatusUnknownStr, time.Now()})
			return
		}
		encoder.Encode(getReleaseResponse{
			nil,
			release.Identifier,
			"ims", // TODO - Do we need to support other group names? How?
			release.Version,
			release.Status,
			release.ReleasedOn,
		})
	}
}

// PUT /projects/{projectId}/releases/{releaseId}

type updateReleaseRequest struct {
	ProjectID  uint32 // Pulled from the URL params
	ReleaseID  uint32 // Pulled from the URL params
	Identifier string `json:"identifier"`
	Version    uint32 `json:"version"`
	Status     string `json:"status"`
}

type updateReleaseResponse struct {
	Error   *string `json:"error"`
	Success bool    `json:"success"`
}

// updateRelease updates the chapter, version, and status of a release.
func updateRelease(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := updateReleaseRequest{}
		vars := mux.Vars(r)
		_, parseErr1 := fmt.Sscanf(vars["projectId"], "%d", &request.ProjectID)
		_, parseErr2 := fmt.Sscanf(vars["releaseId"], "%d", &request.ReleaseID)
		decoder := json.NewDecoder(r.Body)
		defer r.Body.Close()
		decodeErr := decoder.Decode(&request)

		encoder := json.NewEncoder(w)
		if parseErr1 != nil || parseErr2 != nil {
			log.Println("[---] Parse error")
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId and releaseId must both be integer IDs."
			encoder.Encode(updateReleaseResponse{&errMsg, false})
			return
		}
		if decodeErr != nil {
			log.Println("[---] Decode error")
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "Failed to decode JSON in the request body."
			encoder.Encode(updateReleaseResponse{&errMsg, false})
			return
		}

		release, err := models.FindRelease(db, request.ProjectID, request.ReleaseID)
		if err != nil {
			log.Println("[---] Release not found")
			w.WriteHeader(http.StatusNotFound)
			return
		}

		if release.Version > request.Version {
			log.Println("[---] Update error: downversioning not allowed")
			w.WriteHeader(http.StatusExpectationFailed)
			errMsg := "Downversioning is not allowed."
			encoder.Encode(updateReleaseResponse{&errMsg, false})
			return
		}

		if release.Status != request.Status && release.Version == request.Version && request.Status == models.RStatusReleasedStr {
			log.Println("[---] Update error: you must upversion when publishing")
			w.WriteHeader(http.StatusExpectationFailed)
			errMsg := "Upversioning is mandatory when publishing release."
			encoder.Encode(updateReleaseResponse{&errMsg, false})
			return
		}

		release.Version = request.Version
		release.Identifier = request.Identifier
		release.Status = request.Status

		updateErr := release.Update(db)
		if updateErr != nil {
			log.Println("[---] Update error:", updateErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not update the specified release. Please check that the releaseId is correct or try again later."
			encoder.Encode(updateReleaseResponse{&errMsg, false})
			return
		}
		encoder.Encode(updateReleaseResponse{nil, true})
	}
}

// DELETE /projects/{projectId}/releases/{releaseId}

type deleteReleaseRequest struct {
	ProjectID uint32
	ReleaseID uint32
}

type deleteReleaseResponse struct {
	Error   *string `json:"error"`
	Success bool    `json:"success"`
}

// deleteRelease deletes a release from the DB and also all associated pages.
func deleteRelease(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := deleteReleaseRequest{}
		vars := mux.Vars(r)
		_, parseErr1 := fmt.Sscanf(vars["projectId"], "%d", &request.ProjectID)
		_, parseErr2 := fmt.Sscanf(vars["releaseId"], "%d", &request.ReleaseID)

		encoder := json.NewEncoder(w)
		if parseErr1 != nil || parseErr2 != nil {
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId and releaseId must both be integer IDs."
			encoder.Encode(deleteReleaseResponse{&errMsg, false})
			return
		}

		release, err := models.FindRelease(db, request.ProjectID, request.ReleaseID)
		if err != nil {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		pages, err := models.ListPages(db, request.ReleaseID)
		if err != nil {
			log.Println("[---] Delete error:", err)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Unexpected error."
			encoder.Encode(deleteProjectResponse{&errMsg, false})
			return
		}

		if len(pages) > 0 {
			log.Println("[---] Delete error: pages not empty")
			w.WriteHeader(http.StatusExpectationFailed)
			errMsg := "All pages must be deleted before deleting a release."
			encoder.Encode(deleteProjectResponse{&errMsg, false})
			return
		}

		deleteErr := release.Delete(db)
		if deleteErr != nil {
			log.Println("[---] Delete error:", deleteErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not delete the release. Please check that the releaseId is correct or try again later."
			encoder.Encode(deleteReleaseResponse{&errMsg, false})
			return
		}
		encoder.Encode(deleteReleaseResponse{nil, true})
	}
}

func downloadRelease(db *sql.DB, cfg *config.Config, sp storage_provider.Binary) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		var projectId uint32
		var releaseId uint32

		_, parseErr1 := fmt.Sscanf(vars["projectId"], "%d", &projectId)
		_, parseErr2 := fmt.Sscanf(vars["releaseId"], "%d", &releaseId)
		archiveName := vars["name"]

		if parseErr1 != nil || parseErr2 != nil {
			log.Println("failed to parse input parameters")
			w.WriteHeader(http.StatusNotFound)
			return
		}

		project, err := models.FindProject(db, projectId)
		if err != nil {
			log.Println("unable to find project")
			w.WriteHeader(http.StatusNotFound)
			return
		}

		release, err := models.FindRelease(db, projectId, releaseId)
		if err != nil {
			log.Println("unable to find release")
			w.WriteHeader(http.StatusNotFound)
			return
		}

		if release.Status != models.RStatusReleasedStr {
			log.Println("the requested release is not in released state")
			w.WriteHeader(http.StatusNotFound)
			return
		}

		archiveNameExpected := models.GenerateArchiveName(project, release)
		if archiveNameExpected != archiveName {
			log.Printf("requested archive name '%s' does not match expected '%s'\n", archiveName, archiveNameExpected)
			w.WriteHeader(http.StatusNotFound)
			return
		}

		pages, err := models.ListPages(db, release.Id)
		if err != nil {
			log.Println("failed to retrieve list of pages")
			w.WriteHeader(http.StatusNotFound)
			return
		}

		buffer := new(bytes.Buffer)
		z := zip.NewWriter(buffer)

		for _, page := range pages {
			filePath := models.GeneratePagePath(project, release, page.Name)
			imgData, err := sp.Get(filePath)
			if err != nil {
				log.Printf("failed to retrieve image data for %s\n", filePath)
				w.WriteHeader(http.StatusNotFound)
				return
			}

			f, err := z.Create(page.Name)
			if err != nil {
				log.Printf("failed to add image %s to archive\n", filePath)
				w.WriteHeader(http.StatusNotFound)
				return
			}
			_, err = f.Write(imgData)
			if err != nil {
				log.Printf("failed to add image %s to archive\n", filePath)
				w.WriteHeader(http.StatusNotFound)
				return
			}
		}
		err = z.Close()
		if err != nil {
			log.Printf("failed when finalizing archive\n")
			w.WriteHeader(http.StatusNotFound)
			return
		}

		w.Header().Set("Content-Type", "application/zip")
		w.Write(buffer.Bytes())
	}
}
