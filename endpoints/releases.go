package endpoints

import (
	"ims-release/database"
	"ims-release/models"
	"ims-release/storage_provider"

	"archive/zip"
	"bytes"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

var (
	mNewRelease          = models.NewRelease
	mFindRelease         = models.FindRelease
	mSaveRelease         = models.SaveRelease
	mUpdateRelease       = models.UpdateRelease
	mDeleteRelease       = models.DeleteRelease
	mListPages           = models.ListPages
	mGenerateArchiveName = models.GenerateArchiveName
	mGeneratePagePath    = models.GeneratePagePath
)

var (
	ErrMsgListReleases   = "Could not obtain a list of releases. Please try again later."
	ErrRspListReleases   = NewApiResponse(http.StatusInternalServerError, &ErrMsgListReleases)
	ErrMsgCreateRelease  = "Could not create new release. Please check that the status is valid or try again later."
	ErrRspCreateRelease  = NewApiResponse(http.StatusInternalServerError, &ErrMsgCreateRelease)
	ErrMsgDownversioning = "Downversioning is not allowed."
	ErrRspDownversioning = NewApiResponse(http.StatusExpectationFailed, &ErrMsgDownversioning)
	ErrMsgMustUpversion  = "Upversioning is mandatory when publishing release."
	ErrRspMustUpversion  = NewApiResponse(http.StatusExpectationFailed, &ErrMsgMustUpversion)
	ErrMsgReleaseUpdate  = "Could not update specified release. Please ensure the status and identifier are correct."
	ErrRspReleaseUpdate  = NewApiResponse(http.StatusInternalServerError, &ErrMsgReleaseUpdate)
	ErrMsgPagesNotEmpty  = "All pages must be deleted before deleting a release."
	ErrRspPagesNotEmpty  = NewApiResponse(http.StatusExpectationFailed, &ErrMsgPagesNotEmpty)
	ErrMsgReleaseDelete  = "Could not delete the release. Please check that the releaseId is correct or try again later."
	ErrRspReleaseDelete  = NewApiResponse(http.StatusInternalServerError, &ErrMsgReleaseDelete)
)

type ReleaseResponse struct {
	ApiResponse
	Result []models.Release `json:"result"`
}

func NewReleaseResponse(a ApiResponse, r []models.Release) ReleaseResponse {
	return ReleaseResponse{ApiResponse: a, Result: r}
}

// RegisterReleaseHandlers attaches the closures generated by each function defined below
// to handle incoming requests to the appropriate endpoint using a subrouter with an
// appropriate prefix, specified in main.
func RegisterReleaseHandlers(r *mux.Router, db database.DB, sp storage_provider.Binary) {
	root := "/projects/{projectId:[0-9]+}/releases"
	sr := r.PathPrefix(root).Subrouter()
	r.HandleFunc(root, listReleases(db)).Methods("GET")
	r.HandleFunc(root, createRelease(db)).Methods("POST")
	sr.HandleFunc("/{releaseId:[0-9]+}", getRelease(db)).Methods("GET")
	sr.HandleFunc("/{releaseId:[0-9]+}", updateRelease(db)).Methods("PUT")
	sr.HandleFunc("/{releaseId:[0-9]+}", deleteRelease(db)).Methods("DELETE")
	sr.HandleFunc("/{releaseId:[0-9]+}/download/{name:.*}", downloadRelease(db, sp)).Methods("GET")
}

// GET /projects/{projectId}/releases
// listReleases produces a list of all releases under a given project.
func listReleases(db database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		project, err := fetchProjectUsingRequestArgs(db, w, r)
		if err != nil {
			log.Println("[---] Project fetch error:", err)
			// response already set
			return
		}

		releases, err := mListReleases(db, project)
		if err != nil {
			log.Println("[---] Listing error:", err)
			encodeHelper(w, NewReleaseResponse(ErrRspListReleases, []models.Release{}))
			return
		}

		encodeHelper(w, NewReleaseResponse(NoErr, releases))
	}
}

// POST /projects/{projectId}/releases

// createRelease inserts a new release into the database.
func createRelease(db database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		project, err := fetchProjectUsingRequestArgs(db, w, r)
		if err != nil {
			log.Println("[---] Project fetch error:", err)
			// response already set
			return
		}

		request := models.Release{}
		err = decodeHelper(r, &request)
		if err != nil {
			encodeHelper(w, NewReleaseResponse(ErrRspJsonDecode, []models.Release{}))
			return
		}

		release := mNewRelease(project, request.Identifier, request.Version, request.Status, time.Now())
		release, err = mSaveRelease(db, release)
		if err != nil {
			log.Println("[---] Insert error:", err)
			encodeHelper(w, NewReleaseResponse(ErrRspCreateRelease, []models.Release{}))
			return
		}

		encodeHelper(w, NewReleaseResponse(NoErr, []models.Release{release}))
	}
}

// GET /projects/{projectId}/releases/{releaseId}
func fetchReleaseUsingRequestArgs(db database.DB, w http.ResponseWriter, r *http.Request) (models.Project, models.Release, error) {
	project, err := fetchProjectUsingRequestArgs(db, w, r)
	if err != nil {
		return models.Project{}, models.Release{}, err
	}

	vars := mux.Vars(r)
	var releaseId uint32
	numFound, err := fmt.Sscanf(vars["releaseId"], "%d", &releaseId)
	if numFound != 1 || err != nil {
		encodeHelper(w, NewReleaseResponse(ErrRspBadRequest, []models.Release{}))
		return project, models.Release{}, err
	}

	release, err := mFindRelease(db, project, releaseId)
	if err != nil {
		encodeHelper(w, NewReleaseResponse(ErrRspNotFound, []models.Release{}))
		return project, models.Release{}, err
	}

	return project, release, nil
}

// getRelease obtains information about a specific release.
func getRelease(db database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		_, release, err := fetchReleaseUsingRequestArgs(db, w, r)
		if err != nil {
			log.Println("[---] Release fetch error:", err)
			// response already set
			return
		}
		encodeHelper(w, NewReleaseResponse(NoErr, []models.Release{release}))
	}
}

// PUT /projects/{projectId}/releases/{releaseId}
// updateRelease updates the chapter, version, and status of a release.
func updateRelease(db database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		_, release, err := fetchReleaseUsingRequestArgs(db, w, r)
		if err != nil {
			log.Println("[---] Release fetch error:", err)
			// response already set
			return
		}

		request := models.Release{}
		err = decodeHelper(r, &request)
		if err != nil {
			encodeHelper(w, NewReleaseResponse(ErrRspJsonDecode, []models.Release{}))
			return
		}

		if release.Version > request.Version {
			log.Println("[---] Update error: downversioning not allowed")
			encodeHelper(w, NewReleaseResponse(ErrRspDownversioning, []models.Release{}))
			return
		}

		if release.Status != request.Status && release.Version == request.Version && request.Status == models.RStatusReleasedStr {
			log.Println("[---] Update error: you must upversion when publishing")
			encodeHelper(w, NewReleaseResponse(ErrRspMustUpversion, []models.Release{}))
			return
		}

		release.Version = request.Version
		release.Identifier = request.Identifier
		release.Status = request.Status
		release.ReleasedOn = time.Now()

		release, err = mUpdateRelease(db, release)
		if err != nil {
			log.Println("[---] Update error:", err)
			encodeHelper(w, NewReleaseResponse(ErrRspReleaseUpdate, []models.Release{}))
			return
		}
		encodeHelper(w, NewReleaseResponse(NoErr, []models.Release{release}))
	}
}

// DELETE /projects/{projectId}/releases/{releaseId}

// deleteRelease deletes a release from the DB and also all associated pages.
func deleteRelease(db database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		_, release, err := fetchReleaseUsingRequestArgs(db, w, r)
		if err != nil {
			log.Println("[---] Release fetch error:", err)
			// response already set
			return
		}

		pages, err := mListPages(db, release)
		if err != nil {
			log.Println("[---] Delete error:", err)
			encodeHelper(w, NewReleaseResponse(ErrRspUnexpected, []models.Release{}))
			return
		}

		if len(pages) > 0 {
			log.Println("[---] Delete error: pages not empty")
			encodeHelper(w, NewReleaseResponse(ErrRspPagesNotEmpty, []models.Release{}))
			return
		}

		release, err = mDeleteRelease(db, release)
		if err != nil {
			log.Println("[---] Delete error:", err)
			encodeHelper(w, NewReleaseResponse(ErrRspReleaseDelete, []models.Release{}))
			return
		}
		encodeHelper(w, NewReleaseResponse(NoErr, []models.Release{release}))
	}
}

func downloadRelease(db database.DB, sp storage_provider.Binary) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		project, release, err := fetchReleaseUsingRequestArgs(db, w, r)
		if err != nil {
			log.Println("[---] Release fetch error:", err)
			// response already set
			return
		}

		vars := mux.Vars(r)
		archiveName := vars["name"]

		if release.Status != models.RStatusReleasedStr {
			log.Println("the requested release is not in released state")
			w.WriteHeader(http.StatusNotFound)
			return
		}

		archiveNameExpected := mGenerateArchiveName(project, release)
		if archiveNameExpected != archiveName {
			log.Printf("requested archive name '%s' does not match expected '%s'\n", archiveName, archiveNameExpected)
			w.WriteHeader(http.StatusNotFound)
			return
		}

		pages, err := mListPages(db, release)
		if err != nil {
			log.Println("failed to retrieve list of pages")
			w.WriteHeader(http.StatusNotFound)
			return
		}

		buffer := new(bytes.Buffer)
		z := zip.NewWriter(buffer)

		for _, page := range pages {
			filePath := mGeneratePagePath(project, release, page.Name)
			imgData, err := sp.Get(filePath)
			if err != nil {
				log.Printf("failed to retrieve image data for %s\n", filePath)
				w.WriteHeader(http.StatusNotFound)
				return
			}

			f, err := z.Create(page.Name)
			if err != nil {
				log.Printf("failed to add image %s to archive\n", filePath)
				w.WriteHeader(http.StatusNotFound)
				return
			}
			_, err = f.Write(imgData)
			if err != nil {
				log.Printf("failed to add image %s to archive\n", filePath)
				w.WriteHeader(http.StatusNotFound)
				return
			}
		}
		err = z.Close()
		if err != nil {
			log.Printf("failed when finalizing archive\n")
			w.WriteHeader(http.StatusNotFound)
			return
		}

		w.Header().Set("Content-Type", "application/zip")
		w.Write(buffer.Bytes())
	}
}
