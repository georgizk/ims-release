package endpoints

import (
	"../config"
	"../models"

	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/gorilla/mux"
)

// RegisterReleaseHandlers attaches the closures generated by each function defined below
// to handle incoming requests to the appropriate endpoint using a subrouter with an
// appropriate prefix, specified in main.
func RegisterReleaseHandlers(r *mux.Router, db *sql.DB, cfg *config.Config) {
	r.HandleFunc("/", listReleases(db, cfg)).Methods("GET")
	r.HandleFunc("/", createRelease(db, cfg)).Methods("POST")
	r.HandleFunc("/{releaseId}", getRelease(db, cfg)).Methods("GET")
	r.HandleFunc("/{releaseId}", updateRelease(db, cfg)).Methods("PUT")
	r.HandleFunc("/{releaseId}", deleteRelease(db, cfg)).Methods("DELETE")
}

// GET /projects/{projectId}/releases

type listReleasesRequest struct {
	ProjectID int
	Ordering  string
}

type listReleasesResponse struct {
	Error    *string          `json:"error"`
	Releases []models.Release `json:"releases"`
}

// listReleases produces a list of all releases under a given project.
// It accepts an "ordering" parameter, which can be either "newest" or "oldest"
// to specify which should come first.
func listReleases(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		pid := mux.Vars(r)["projectId"]
		projectId, parseErr := strconv.Atoi(pid)
		request := listReleasesRequest{0, "newest"}
		orderings, found := r.URL.Query()["ordering"]
		if found {
			request.Ordering = orderings[0]
		}

		encoder := json.NewEncoder(w)
		if parseErr != nil {
			fmt.Println("[---] Parse error:", parseErr)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId must be an integer ID."
			encoder.Encode(listReleasesResponse{&errMsg, []models.Release{}})
			return
		}
		request.ProjectID = projectId
		releases, listErr := models.ListReleases(request.ProjectID, request.Ordering, db)
		if listErr != nil {
			fmt.Println("[---] List error:", listErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not list releases. Please check that the projectId is correct or try again later."
			encoder.Encode(listReleasesResponse{&errMsg, []models.Release{}})
			return
		}
		encoder.Encode(listReleasesResponse{nil, releases})
	}
}

// POST /projects/{projectId}/releases

type createReleaseRequest struct {
	ProjectID int                  // Pulled from the URL parameters
	Chapter   string               `json:"chapter"`
	Version   int                  `json:"version"`
	Status    models.ReleaseStatus `json:"status"`
}

type createReleaseResponse struct {
	Error   *string `json:"error"`
	Success bool    `json:"success"`
	Id      int     `json:"id"`
}

// createRelease inserts a new release into the database.
func createRelease(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := createReleaseRequest{}
		projectId, parseErr := strconv.Atoi(mux.Vars(r)["projectId"])
		decoder := json.NewDecoder(r.Body)
		defer r.Body.Close()
		decodeErr := decoder.Decode(&request)

		encoder := json.NewEncoder(w)
		if parseErr != nil {
			fmt.Println("[---] Parse error:", parseErr)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId must be an integer project ID."
			encoder.Encode(createReleaseResponse{&errMsg, false, -1})
			return
		}
		request.ProjectID = projectId
		if decodeErr != nil {
			fmt.Println("[---] Decode error:", decodeErr)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "JSON format error or missing field detected."
			encoder.Encode(createReleaseResponse{&errMsg, false, -1})
			return
		}
		release := models.NewRelease(request.ProjectID, request.Version, request.Chapter)
		release.Status = request.Status
		insertErr := release.Save(db)
		if insertErr != nil {
			fmt.Println("[---] Insert error:", insertErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not create new release. Please check that the status is valid or try again later."
			encoder.Encode(createReleaseResponse{&errMsg, false, -1})
			return
		}
		encoder.Encode(createReleaseResponse{nil, true, release.Id})
	}
}

// GET /projects/{projectId}/releases/{releaseId}

type getReleaseRequest struct {
	ProjectID int
	ReleaseID int
}

type getReleaseResponse struct {
	Error       *string              `json:"error"`
	ProjectName string               `json:"projectName"`
	Chapter     string               `json:"chapter"`
	GroupName   string               `json:"groupName"`
	Checksum    string               `json:"checksum"`
	Version     int                  `json:"version"`
	Status      models.ReleaseStatus `json:"status"`
	ReleasedOn  time.Time            `json:"releasedOn"`
}

// getRelease obtains information about a specific release.
func getRelease(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := getReleaseRequest{}
		vars := mux.Vars(r)
		pid := vars["projectId"]
		rid := vars["releaseId"]
		projectId, parseErr1 := strconv.Atoi(pid)
		releaseId, parseErr2 := strconv.Atoi(rid)

		encoder := json.NewEncoder(w)
		if parseErr1 != nil || parseErr2 != nil {
			fmt.Printf("[---] Parse error: %v || %v\n", parseErr1, parseErr2)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId and releaseId must be integer IDs."
			encoder.Encode(getReleaseResponse{&errMsg, "", "", "", "", 0, "", time.Now()})
			return
		}
		request.ProjectID = projectId
		request.ReleaseID = releaseId
		project, findErr := models.FindProject(request.ProjectID, db)
		if findErr != nil {
			fmt.Printf("[---] Find error:", findErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not find requested project. Please check that the projectId is correct or try again later."
			encoder.Encode(getReleaseResponse{&errMsg, "", "", "", "", 0, "", time.Now()})
			return
		}
		release, findErr := models.FindRelease(request.ReleaseID, db)
		if findErr != nil {
			fmt.Printf("[---] Find error:", findErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not find requested release. Please check that the releaseId is correct or try again later."
			encoder.Encode(getReleaseResponse{&errMsg, "", "", "", "", 0, "", time.Now()})
			return
		}
		encoder.Encode(getReleaseResponse{
			nil,
			project.Shorthand,
			release.Chapter,
			"ims", // TODO - Do we need to support other group names? How?
			release.Checksum,
			release.Version,
			release.Status,
			release.ReleasedOn,
		})
	}
}

// PUT /projects/{projectId}/releases/{releaseId}

type updateReleaseRequest struct {
	ProjectID int                  // Pulled from the URL params
	ReleaseID int                  // Pulled from the URL params
	Chapter   string               `json:"chapter"`
	Version   int                  `json:"version"`
	Status    models.ReleaseStatus `json:"status"`
}

type updateReleaseResponse struct {
	Error   *string `json:"error"`
	Success bool    `json:"success"`
}

// updateRelease updates the chapter, version, and status of a release.
func updateRelease(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := updateReleaseRequest{}
		vars := mux.Vars(r)
		pid := vars["projectId"]
		rid := vars["releaseId"]
		projectId, parseErr1 := strconv.Atoi(pid)
		releaseId, parseErr2 := strconv.Atoi(rid)
		decoder := json.NewDecoder(r.Body)
		defer r.Body.Close()
		decodeErr := decoder.Decode(&request)

		encoder := json.NewEncoder(w)
		if parseErr1 != nil || parseErr2 != nil {
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId and releaseId must both be integer IDs."
			encoder.Encode(updateReleaseResponse{&errMsg, false})
			return
		}
		request.ProjectID = projectId
		request.ReleaseID = releaseId
		if decodeErr != nil {
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "Failed to decode JSON in the request body."
			encoder.Encode(updateReleaseResponse{&errMsg, false})
			return
		}
		// We could load the release from the database and update its fields but there's no
		// point doing that when we can have the DB update the right row with the releaseId.
		release := models.NewRelease(request.ProjectID, request.Version, request.Chapter)
		release.Id = request.ReleaseID
		release.Status = request.Status
		updateErr := release.Update(db)
		if updateErr != nil {
			fmt.Println("[---] Update error:", updateErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not update the specified release. Please check that the releaseId is correct or try again later."
			encoder.Encode(updateReleaseResponse{&errMsg, false})
			return
		}
		encoder.Encode(updateReleaseResponse{nil, true})
	}
}

// DELETE /projects/{projectId}/releases/{releaseId}

type deleteReleaseRequest struct {
	ProjectID int
	ReleaseID int
}

type deleteReleaseResponse struct {
	Error   *string `json:"error"`
	Success bool    `json:"success"`
}

// deleteRelease deletes a release from the DB and also all associated pages.
func deleteRelease(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := deleteReleaseRequest{}
		vars := mux.Vars(r)
		pid := vars["projectId"]
		rid := vars["releaseId"]
		projectId, parseErr1 := strconv.Atoi(pid)
		releaseId, parseErr2 := strconv.Atoi(rid)

		encoder := json.NewEncoder(w)
		if parseErr1 != nil || parseErr2 != nil {
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId and releaseId must both be integer IDs."
			encoder.Encode(deleteReleaseResponse{&errMsg, false})
			return
		}
		request.ProjectID = projectId
		request.ReleaseID = releaseId
		// TODO - Delete the release from the DB.
		encoder.Encode(deleteReleaseResponse{nil, true})
	}
}
