package endpoints

import (
	"../config"
	"../models"

	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/gorilla/mux"
)

// RegisterProjectHandlers attaches the closures generated by each function defined below
// to handle incoming requests to the appropriate endpoint using a subrouter with an
// appropriate prefix, specified in main.
func RegisterProjectHandlers(r *mux.Router, db *sql.DB, cfg *config.Config) {
	r.HandleFunc("/", listProjects(db, cfg)).Methods("GET")
	r.HandleFunc("/", createProject(db, cfg)).Methods("POST")
	r.HandleFunc("/{projectId}", getProject(db, cfg)).Methods("GET")
	r.HandleFunc("/{projectId}", updateProject(db, cfg)).Methods("PUT")
	r.HandleFunc("/{projectId}", deleteProject(db, cfg)).Methods("DELETE")
}

// GET /projects

type listProjectsRequest struct {
	Ordering string
}

type listProjectsResponse struct {
	Error    *string          `json:"error"`
	Projects []models.Project `json:"projects"`
}

// listProjects produces a list of all projects. It accepts an "ordering"
// parameter, which can be either "newest" or "oldest" to specify which should
// come first.
func listProjects(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := listProjectsRequest{"newest"}
		orderings, found := r.URL.Query()["ordering"]
		if found {
			request.Ordering = orderings[0]
		}

		encoder := json.NewEncoder(w)
		projects, listErr := models.ListProjects(request.Ordering, db)
		if listErr != nil {
			fmt.Println("[---] Listing error:", listErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not obtain a list of projects. Please try again later."
			encoder.Encode(listProjectsResponse{&errMsg, []models.Project{}})
			return
		}
		encoder.Encode(listProjectsResponse{nil, projects})
	}
}

// POST /projects

type createProjectRequest struct {
	Name        string               `json:"name"`
	ProjectName string               `json:"projectName"`
	Description string               `json:"description"`
	Status      models.ProjectStatus `json:"status"`
}

type createProjectResponse struct {
	Error   *string `json:"error"`
	Success bool    `json:"success"`
	Id      int     `json:"id"`
}

// createProject creates a new project.
func createProject(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := createProjectRequest{}
		decoder := json.NewDecoder(r.Body)
		defer r.Body.Close()
		decodeErr := decoder.Decode(&request)

		encoder := json.NewEncoder(w)
		if decodeErr != nil {
			fmt.Println("[---] Decode error:", decodeErr)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "JSON format error or missing field detected."
			encoder.Encode(createProjectResponse{&errMsg, false, -1})
			return
		}
		project := models.NewProject(request.Name, request.ProjectName, request.Description)
		project.Status = request.Status
		insertErr := project.Save(db)
		if insertErr != nil {
			fmt.Println("[---] Insert error:", insertErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not create project. Try again later, or with a different projectName."
			encoder.Encode(createProjectResponse{&errMsg, false, -1})
			return
		}
		encoder.Encode(createProjectResponse{nil, true, project.Id})
	}
}

// GET /projects/{projectId}

type getProjectRequest struct {
	Id int
}

type getProjectResponse struct {
	Error       *string              `json:"error"`
	Name        string               `json:"name"`
	ProjectName string               `json:"projectName"`
	Status      models.ProjectStatus `json:"status"`
	Description string               `json:"description"`
	CreatedAt   time.Time            `json:"createdAt"`
}

// getProject obtains information about a specific project.
func getProject(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := getProjectRequest{}
		projectId, parseErr := strconv.Atoi(mux.Vars(r)["projectId"])

		encoder := json.NewEncoder(w)
		if parseErr != nil {
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId must be an integer ID."
			encoder.Encode(getProjectResponse{&errMsg, "", "", "", "", time.Now()})
			return
		}
		request.Id = projectId
		// TODO - Retrieve the project information from the database.
		encoder.Encode(getProjectResponse{nil, "project", "prj1", models.PStatusOngoing, "A test project", time.Now()})
	}
}

// PUT /projects/{projectId}

type updateProjectRequest struct {
	Id          int                  // Provided from a URL path parameter
	Name        string               `json:"name"`
	ProjectName string               `json:"projectName"`
	Status      models.ProjectStatus `json:"status"`
	Description string               `json:"description"`
}

type updateProjectResponse struct {
	Error   *string `json:"error"`
	Success bool    `json:"success"`
}

// updateProject updates every field of an existing project with some supplied data.
func updateProject(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := updateProjectRequest{}
		projectId, parseErr := strconv.Atoi(mux.Vars(r)["projectId"])
		decoder := json.NewDecoder(r.Body)
		defer r.Body.Close()
		decodeErr := decoder.Decode(&request)

		encoder := json.NewEncoder(w)
		if parseErr != nil {
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId must be an integer ID."
			encoder.Encode(updateProjectResponse{&errMsg, false})
			return
		}
		request.Id = projectId
		if decodeErr != nil {
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "JSON format error or missing field detected."
			encoder.Encode(updateProjectResponse{&errMsg, false})
			return
		}
		// TODO - Update the project in the DB.
		encoder.Encode(updateProjectResponse{nil, true})
	}
}

// DELETE /projects/{projectId}

type deleteProjectRequest struct {
	Id int
}

type deleteProjectResponse struct {
	Error   *string `json:"error"`
	Success bool    `json:"success"`
}

// deleteProject removes an entire project from the database, along with
// all of the releases under that project.
func deleteProject(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := deleteProjectRequest{}
		projectId, parseErr := strconv.Atoi(mux.Vars(r)["projectId"])
		request.Id = request.Id // Shutting the linter up

		encoder := json.NewEncoder(w)
		if parseErr != nil {
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId must be an integer ID."
			encoder.Encode(deleteProjectResponse{&errMsg, false})
			return
		}
		request.Id = projectId
		// TODO - Delete the project in the DB.
		encoder.Encode(deleteProjectResponse{nil, true})
	}
}
