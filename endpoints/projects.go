package endpoints

import (
	"ims-release/database"
	"ims-release/models"

	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

var (
	mListProjects  = models.ListProjects
	mNewProject    = models.NewProject
	mFindProject   = models.FindProject
	mListReleases  = models.ListReleases
	mSaveProject   = models.SaveProject
	mUpdateProject = models.UpdateProject
	mDeleteProject = models.DeleteProject
)

var (
	ErrMsgListProjects     = "Could not obtain a list of projects. Please try again later."
	ErrRspListProjects     = NewApiResponse(http.StatusInternalServerError, &ErrMsgListProjects)
	ErrMsgCreateProject    = "Could not create project. Try again later, or with a different shorthand."
	ErrRspCreateProject    = NewApiResponse(http.StatusInternalServerError, &ErrMsgCreateProject)
	ErrMsgProjectUpdate    = "Could not update specified project. Please ensure the ID and status are correct."
	ErrRspProjectUpdate    = NewApiResponse(http.StatusInternalServerError, &ErrMsgProjectUpdate)
	ErrMsgReleasesNotEmpty = "There are releases for this project."
	ErrRspReleasesNotEmpty = NewApiResponse(http.StatusExpectationFailed, &ErrMsgReleasesNotEmpty)
)

// RegisterProjectHandlers attaches the closures generated by each function defined below
// to handle incoming requests to the appropriate endpoint using a subrouter with an
// appropriate prefix, specified in main.
func RegisterProjectHandlers(r *mux.Router, db database.DB) {
	root := "/projects"
	sr := r.PathPrefix(root).Subrouter()
	r.HandleFunc(root, listProjects(db)).Methods("GET")
	r.HandleFunc(root, createProject(db)).Methods("POST")
	sr.HandleFunc("/{projectId:[0-9]+}", getProject(db)).Methods("GET")
	sr.HandleFunc("/{projectId:[0-9]+}", updateProject(db)).Methods("PUT")
	sr.HandleFunc("/{projectId:[0-9]+}", deleteProject(db)).Methods("DELETE")
}

// GET /projects
type ProjectResponse struct {
	ApiResponse
	Result []models.Project `json:"result"`
}

func NewProjectResponse(a ApiResponse, r []models.Project) ProjectResponse {
	return ProjectResponse{ApiResponse: a, Result: r}
}

// listProjects produces a list of all projects. It accepts an "ordering"
// parameter, which can be either "newest" or "oldest" to specify which should
// come first.

func listProjects(db database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		projects, err := mListProjects(db)
		if err != nil {
			log.Println("[---] Listing error:", err)
			encodeHelper(w, NewProjectResponse(ErrRspListProjects, []models.Project{}))
			return
		}
		encodeHelper(w, NewProjectResponse(NoErr, projects))
	}
}

// POST /projects

// createProject creates a new project.
func createProject(db database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		request := models.Project{}
		err := decodeHelper(r, &request)
		if err != nil {
			encodeHelper(w, NewProjectResponse(ErrRspJsonDecode, []models.Project{}))
			return
		}

		project := mNewProject(request.Name, request.Shorthand, request.Description, request.Status, time.Now())
		project, err = mSaveProject(db, project)
		if err != nil {
			log.Println("[---] Insert error:", err)
			encodeHelper(w, NewProjectResponse(ErrRspCreateProject, []models.Project{}))
			return
		}
		encodeHelper(w, NewProjectResponse(NoErr, []models.Project{project}))
	}
}

// GET /projects/{projectId}
func fetchProjectUsingRequestArgs(db database.DB, w http.ResponseWriter, r *http.Request) (models.Project, error) {
	vars := mux.Vars(r)
	var projectId uint32
	numFound, err := fmt.Sscanf(vars["projectId"], "%d", &projectId)
	if numFound != 1 || err != nil {
		encodeHelper(w, NewProjectResponse(ErrRspBadRequest, []models.Project{}))
		return models.Project{}, err
	}

	project, err := mFindProject(db, projectId)
	if err != nil {
		encodeHelper(w, NewProjectResponse(ErrRspNotFound, []models.Project{}))
		return models.Project{}, err
	}

	return project, nil
}

// getProject obtains information about a specific project.
func getProject(db database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		project, err := fetchProjectUsingRequestArgs(db, w, r)
		if err != nil {
			log.Println("[---] Project fetch error:", err)
			// response already set
			return
		}

		encodeHelper(w, NewProjectResponse(NoErr, []models.Project{project}))
	}
}

// PUT /projects/{projectId}

// updateProject updates every field of an existing project with some supplied data.
func updateProject(db database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		project, err := fetchProjectUsingRequestArgs(db, w, r)
		if err != nil {
			log.Println("[---] Project fetch error:", err)
			// response already set
			return
		}

		request := models.Project{}
		err = decodeHelper(r, &request)
		if err != nil {
			encodeHelper(w, NewProjectResponse(ErrRspJsonDecode, []models.Project{}))
			return
		}

		project.Name = request.Name
		project.Status = request.Status
		project.Shorthand = request.Shorthand
		project.Description = request.Description

		project, err = mUpdateProject(db, project)
		if err != nil {
			log.Println("[---] Update error:", err)
			encodeHelper(w, NewProjectResponse(ErrRspProjectUpdate, []models.Project{}))
			return
		}

		encodeHelper(w, NewProjectResponse(NoErr, []models.Project{project}))
	}
}

// DELETE /projects/{projectId}

// deleteProject removes an entire project from the database
func deleteProject(db database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		project, err := fetchProjectUsingRequestArgs(db, w, r)
		if err != nil {
			log.Println("[---] Project fetch error:", err)
			// response already set
			return
		}

		releases, err := mListReleases(db, project)
		if err != nil {
			log.Println("[---] Delete error:", err)
			encodeHelper(w, NewProjectResponse(ErrRspUnexpected, []models.Project{}))
			return
		}

		if len(releases) > 0 {
			log.Println("[---] Delete error: releases not empty")
			encodeHelper(w, NewProjectResponse(ErrRspReleasesNotEmpty, []models.Project{}))
			return
		}

		project, err = mDeleteProject(db, project)
		if err != nil {
			log.Println("[---] Delete error:", err)
			encodeHelper(w, NewProjectResponse(ErrRspUnexpected, []models.Project{}))
			return
		}
		encodeHelper(w, NewProjectResponse(NoErr, []models.Project{project}))
	}
}
