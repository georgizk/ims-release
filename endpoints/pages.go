package endpoints

import (
	"ims-release/database"
	"ims-release/models"
	"ims-release/storage_provider"

	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	"image/jpeg"
	"image/png"
	"log"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

var (
	mNewPage        = models.NewPage
	mFindPageByName = models.FindPageByName
	mFindPage       = models.FindPage
	mSavePage       = models.SavePage
	mUpdatePage     = models.UpdatePage
	mDeletePage     = models.DeletePage
)

var (
	ErrMsgListPages    = "Could not list pages. Please try again later."
	ErrRspListPages    = NewApiResponse(http.StatusInternalServerError, &ErrMsgListPages)
	ErrMsgWrongType    = "The uploaded image is neither a valid JPG/JPEG or PNG image."
	ErrRspWrongType    = NewApiResponse(http.StatusExpectationFailed, &ErrMsgWrongType)
	ErrMsgBadImageData = "The supplied image data is not base64 encoded."
	ErrRspBadImageData = NewApiResponse(http.StatusExpectationFailed, &ErrMsgBadImageData)
	ErrMsgCreatePage   = "Failed to save image file. Please try again later."
	ErrRspCreatePage   = NewApiResponse(http.StatusInternalServerError, &ErrMsgCreatePage)
	ErrMsgDeletePage   = "Could not delete the requested page. Please try again later."
	ErrRspDeletePage   = NewApiResponse(http.StatusInternalServerError, &ErrMsgDeletePage)
	ErrMsgMustBeDraft  = "Action only allowed when release is in draft state."
	ErrRspMustBeDraft  = NewApiResponse(http.StatusExpectationFailed, &ErrMsgMustBeDraft)
)

type PageResponse struct {
	ApiResponse
	Result []models.Page `json:"result"`
}

func NewPageResponse(a ApiResponse, r []models.Page) PageResponse {
	return PageResponse{ApiResponse: a, Result: r}
}

// RegisterPageHandlers attaches the closures generated by each function defined below
// to handle incoming requests to the appropriate endpoint using a subrouter with an
// appropriate prefix, specified in main.
func RegisterPageHandlers(r *mux.Router, db database.DB, sp storage_provider.Binary) {
	root := "/projects/{projectId:[0-9]+}/releases/{releaseId:[0-9]+}/pages"
	sr := r.PathPrefix(root).Subrouter()
	r.HandleFunc(root, listPages(db)).Methods("GET")
	r.HandleFunc(root, createPage(db, sp)).Methods("POST")
	sr.HandleFunc("/{pageId:[0-9]+}", deletePage(db, sp)).Methods("DELETE")
	sr.HandleFunc("/{name}", getPage(db, sp)).Methods("GET")
}

// GET /projects/{projectId}/releases/{releaseId}/pages
// listPages lists descriptive information about
func listPages(db database.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		_, release, err := fetchReleaseUsingRequestArgs(db, w, r, true)
		if err != nil {
			log.Println("[---] Release fetch error:", err)
			// response already set
			return
		}

		pages, err := mListPages(db, release)
		if err != nil {
			log.Println("[---] List error:", err)
			encodeHelper(w, NewPageResponse(ErrRspListPages, []models.Page{}))
			return
		}
		encodeHelper(w, NewPageResponse(NoErr, pages))
	}
}

type PageCreateReq struct {
	models.Page
	ImageData string `json:"data"`
}

// POST /projects/{projectId}/releases/{releaseId}/pages
// createPage inserts a new page into the DB and saves page data to a file.
func createPage(db database.DB, sp storage_provider.Binary) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		project, release, err := fetchReleaseUsingRequestArgs(db, w, r, true)
		if err != nil {
			log.Println("[---] Release fetch error:", err)
			// response already set
			return
		}

		if release.Status != models.RStatusDraftStr {
			log.Println("[---] Invalid state:", ErrMsgMustBeDraft)
			encodeHelper(w, NewPageResponse(ErrRspMustBeDraft, []models.Page{}))
			return
		}

		request := PageCreateReq{}
		err = decodeHelper(r, &request)
		if err != nil {
			encodeHelper(w, NewPageResponse(ErrRspJsonDecode, []models.Page{}))
			return
		}

		imageData, err := base64.StdEncoding.DecodeString(request.ImageData)
		if err != nil {
			log.Println("[---] Image decode error:", err)
			encodeHelper(w, NewPageResponse(ErrRspBadImageData, []models.Page{}))
			return
		}
		log.Println("[+++] Successfully decoded image data")

		page := mNewPage(release, request.Name, time.Now())
		mimeType := page.MimeType
		switch mimeType {
		case models.MimeTypePng:
			_, err = png.Decode(bytes.NewReader(imageData))
		case models.MimeTypeJpg:
			_, err = jpeg.Decode(bytes.NewReader(imageData))
		case models.MimeTypeUnknown:
			fallthrough
		default:
			err = errors.New("bad extension")
		}

		if err != nil {
			// The image is neither a valid JPG/JPEG nor a valid PNG image.
			log.Printf("[---] Uploaded error: %v\n", err)
			encodeHelper(w, NewPageResponse(ErrRspWrongType, []models.Page{}))
			return
		}

		filePath := mGeneratePagePath(project, release, page.Name)

		log.Printf("[+++] Computed filename %s\n", filePath)
		err = sp.Set(filePath, imageData)
		if err != nil {
			log.Println("[---] Save error:", err)
			encodeHelper(w, NewPageResponse(ErrRspCreatePage, []models.Page{}))
			return
		}
		log.Println("[+++] Successfully saved image to disk")

		page, err = mSavePage(db, page)
		if err != nil {
			log.Println("[---] Insert error:", err)
			encodeHelper(w, NewPageResponse(ErrRspCreatePage, []models.Page{}))
			sp.Unset(filePath)
			return
		}
		encodeHelper(w, NewPageResponse(NoErr, []models.Page{page}))
	}
}

func getPage(db database.DB, sp storage_provider.Binary) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		project, release, err := fetchReleaseUsingRequestArgs(db, w, r, false)
		if err != nil {
			log.Println("[---] Release fetch error:", err)
			w.WriteHeader(http.StatusNotFound)
			return
		}

		vars := mux.Vars(r)
		page, err := mFindPageByName(db, release, vars["name"])
		if err != nil {
			log.Println("[---] Find error:", err)
			w.WriteHeader(http.StatusNotFound)
			return
		}

		path := mGeneratePagePath(project, release, page.Name)
		imageBytes, err := sp.Get(path)
		if err != nil {
			log.Println("[---] error:", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusOK)
		w.Header().Set("Content-Type", page.MimeType.String())
		w.Write(imageBytes)
	}
}

func fetchPageUsingRequestArgs(db database.DB, w http.ResponseWriter, r *http.Request, writeResponse bool) (models.Project, models.Release, models.Page, error) {
	project, release, err := fetchReleaseUsingRequestArgs(db, w, r, writeResponse)
	if err != nil {
		return models.Project{}, models.Release{}, models.Page{}, err
	}

	vars := mux.Vars(r)
	var pageId uint32
	numFound, err := fmt.Sscanf(vars["pageId"], "%d", &pageId)
	if numFound != 1 || err != nil {
		if writeResponse {
			encodeHelper(w, NewPageResponse(ErrRspBadRequest, []models.Page{}))
		}

		return project, release, models.Page{}, err
	}

	page, err := mFindPage(db, release, pageId)
	if err != nil {
		if writeResponse {
			encodeHelper(w, NewPageResponse(ErrRspNotFound, []models.Page{}))
		}
		return project, release, models.Page{}, err
	}
	return project, release, page, nil
}

// DELETE /projects/{projectId}/releases/{releaseId}/pages/{pageId}
// deletePage removes a page from the DB and deletes the file containing the image.
func deletePage(db database.DB, sp storage_provider.Binary) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		project, release, page, err := fetchPageUsingRequestArgs(db, w, r, true)
		if err != nil {
			log.Println("[---] Page fetch error:", err)
			// response already set
			return
		}

		if release.Status != models.RStatusDraftStr {
			log.Println("[---] Invalid state:", ErrMsgMustBeDraft)
			encodeHelper(w, NewPageResponse(ErrRspMustBeDraft, []models.Page{}))
			return
		}

		filePath := mGeneratePagePath(project, release, page.Name)
		log.Println("[+++] Attempting to delete page", page)
		page, err = mDeletePage(db, page)
		if err != nil {
			log.Println("[---] Delete error:", err)
			encodeHelper(w, NewPageResponse(ErrRspDeletePage, []models.Page{}))
			return
		}
		sp.Unset(filePath)
		encodeHelper(w, NewPageResponse(NoErr, []models.Page{page}))
	}
}
