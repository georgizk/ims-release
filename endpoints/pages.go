package endpoints

import (
	"../config"
	"../models"

	"bytes"
	"crypto/rand"
	"database/sql"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"image/jpeg"
	"image/png"
	"net/http"
	"os"
	"path"
	"strconv"

	"github.com/gorilla/mux"
)

// randomFilename produces a random 16-character (8-byte) hex string which, when formatted like
// {rand}.{ext} is a filename for an image with a given extension that is not already taken.
// Since the space of acceptable file names is so large despite requiring so few random bytes,
// this function should only execute the code within each loop once.
func randomFilename(cfg *config.Config, ext string) string {
	fname := ""
	randBytes := make([]byte, 8)
	generatedFName := false
	// Keep trying to generate names until we find one that isn't taken.
	for !generatedFName {
		generatedBytes := false
		// Keep trying to read random bytes until we definitely fill the buffer.
		for !generatedBytes {
			_, genErr := rand.Read(randBytes)
			generatedBytes = genErr == nil
			fmt.Printf("[+++] Generated bytes %v | Error: %v\n", randBytes, genErr)
		}
		fname = path.Join(cfg.ImageDirectory, hex.EncodeToString(randBytes)+"."+ext)
		fmt.Println("[+++] Generated file name", fname)
		_, findErr := os.Stat(fname)
		generatedFName = findErr != nil
	}
	return fname
}

// RegisterPageHandlers attaches the closures generated by each function defined below
// to handle incoming requests to the appropriate endpoint using a subrouter with an
// appropriate prefix, specified in main.
func RegisterPageHandlers(r *mux.Router, db *sql.DB, cfg *config.Config) {
	r.HandleFunc("/", listPages(db, cfg)).Methods("GET")
	r.HandleFunc("/", createPage(db, cfg)).Methods("POST")
	r.HandleFunc("/{pageId}", deletePage(db, cfg)).Methods("DELETE")
}

// GET /projects/{projectId}/releases/{releaseId}/pages

type listPagesRequest struct {
	ProjectID int
	ReleaseID int
}

type listPagesResponse struct {
	Error *string       `json:"error"`
	Pages []models.Page `json:"pages"`
}

// listPages lists descriptive information about
func listPages(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := listPagesRequest{}
		vars := mux.Vars(r)
		pid := vars["projectId"]
		rid := vars["releaseId"]
		projectId, parseErr1 := strconv.Atoi(pid)
		releaseId, parseErr2 := strconv.Atoi(rid)

		encoder := json.NewEncoder(w)
		if parseErr1 != nil || parseErr2 != nil {
			fmt.Printf("[---] Parse error: %v || %v\n", parseErr1, parseErr2)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId and releaseId must be integer IDs."
			encoder.Encode(listPagesResponse{&errMsg, []models.Page{}})
			return
		}
		request.ProjectID = projectId
		request.ReleaseID = releaseId
		pages, listErr := models.ListPages(request.ReleaseID, db)
		if listErr != nil {
			fmt.Println("[---] List error:", listErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Could not list pages. Please check that the projectId is correct or try again later."
			encoder.Encode(listPagesResponse{&errMsg, []models.Page{}})
			return
		}
		encoder.Encode(listPagesResponse{nil, pages})
	}
}

// POST /projects/{projectId}/releases/{releaseId}/pages

type createPageRequest struct {
	ProjectID int    // Pulled from the URL parameters
	ReleaseID int    // Pulled from the URL parameters
	Number    string `json:"page"`
	ImageData string `json:"data"`
}

type createPageResponse struct {
	Error   *string `json:"error"`
	Success bool    `json:"success"`
	ID      int     `json:"id"`
}

// createPage inserts a new page into the DB and saves page data to a file.
func createPage(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := createPageRequest{}
		vars := mux.Vars(r)
		pid := vars["projectId"]
		rid := vars["releaseId"]
		projectId, parseErr1 := strconv.Atoi(pid)
		releaseId, parseErr2 := strconv.Atoi(rid)
		decoder := json.NewDecoder(r.Body)
		defer r.Body.Close()
		decodeErr := decoder.Decode(&request)
		fmt.Printf("[+++] Project ID = %d, Release ID = %d\n", projectId, releaseId)

		encoder := json.NewEncoder(w)
		if parseErr1 != nil || parseErr2 != nil {
			fmt.Printf("[---] Parse error: %v || %v\n", parseErr1, parseErr2)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId and releaseId must be integer IDs."
			encoder.Encode(createPageResponse{&errMsg, false, 0})
			return
		}
		request.ProjectID = projectId
		request.ReleaseID = releaseId
		if decodeErr != nil {
			fmt.Println("[---] Decode error:", decodeErr)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "JSON format error or missing field detected."
			encoder.Encode(createPageResponse{&errMsg, false, 0})
			return
		}
		imageData, decodeErr := base64.StdEncoding.DecodeString(request.ImageData)
		if decodeErr != nil {
			fmt.Println("[---] Image decode error:", decodeErr)
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "The supplied image data is not base64 encoded."
			encoder.Encode(createPageResponse{&errMsg, false, 0})
			return
		}
		fmt.Println("[+++] Successfully decoded image data")
		var filePath string // The path that the image ends up being saved to.
		_, jpgParseErr := jpeg.Decode(bytes.NewReader(imageData))
		if jpgParseErr != nil {
			_, pngParseErr := png.Decode(bytes.NewReader(imageData))
			if pngParseErr != nil {
				// The image is neither a valid JPG/JPEG nor a valid PNG image.
				fmt.Printf("[---] Uploaded error: %v && %v\n", jpgParseErr, pngParseErr)
				w.WriteHeader(http.StatusBadRequest)
				errMsg := "The uploaded image is neither a valid JPG/JPEG or PNG image."
				encoder.Encode(createPageResponse{&errMsg, false, -1})
				return
			} else {
				// The image is a valid PNG image.
				filePath = randomFilename(cfg, "png")
			}
		} else {
			// The image is a valid JPG/JPEG image.
			filePath = randomFilename(cfg, "jpg")
		}
		fmt.Printf("[+++] Computed filename %s\n", filePath)
		f, saveErr := os.Create(filePath)
		if saveErr == nil {
			_, saveErr = f.Write(imageData)
		}
		defer f.Close()
		if saveErr != nil {
			fmt.Println("[---] Save error:", saveErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Failed to save image file. Please try again later."
			encoder.Encode(createPageResponse{&errMsg, false, -1})
			return
		}
		fmt.Println("[+++] Successfully saved image to disk")
		page := models.NewPage(request.Number, filePath, request.ReleaseID)
		saveErr = page.Save(db)
		if saveErr != nil {
			fmt.Println("[---] Insert error:", saveErr)
			w.WriteHeader(http.StatusInternalServerError)
			errMsg := "Failed to save page. Please try again later."
			encoder.Encode(createPageResponse{&errMsg, false, -1})
			return
		}
		encoder.Encode(createPageResponse{nil, true, page.Id})
	}
}

// DELETE /projects/{projectId}/releases/{releaseId}/pages/{pageId}

type deletePageRequest struct {
	ProjectID int
	ReleaseID int
	PageID    int
}

type deletePageResponse struct {
	Error   *string `json:"error"`
	Success bool    `json:"success"`
}

// deletePage removes a page from the DB and deletes the file containing the image.
func deletePage(db *sql.DB, cfg *config.Config) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		request := deletePageRequest{}
		vars := mux.Vars(r)
		prid := vars["projectId"]
		reid := vars["releaseId"]
		paid := vars["pageId"]
		projectId, parseErr1 := strconv.Atoi(prid)
		releaseId, parseErr2 := strconv.Atoi(reid)
		pageId, parseErr3 := strconv.Atoi(paid)

		encoder := json.NewEncoder(w)
		if parseErr1 != nil || parseErr2 != nil || parseErr3 != nil {
			w.WriteHeader(http.StatusBadRequest)
			errMsg := "projectId, releaseId, and pageId must all be integer IDs."
			encoder.Encode(deletePageResponse{&errMsg, false})
			return
		}
		request.ProjectID = projectId
		request.ReleaseID = releaseId
		request.PageID = pageId
		// TODO - Delete the page from the DB and the file from disk.
		encoder.Encode(deletePageResponse{nil, true})
	}
}
